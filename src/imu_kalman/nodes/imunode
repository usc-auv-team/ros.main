#!/usr/bin/env python

from geometry_msgs.msg import Vector3Stamped
import imu_kalman.msg as messages
import rospy

first_update = True

init_an = 0.0
init_ae = 0.0
init_ad = 0.0
init_vn = 0.0
init_ve = 0.0
init_vd = 0.0
init_dn = 0.0
init_de = 0.0
init_dd = 0.0

init_time_stamp = rospy.Time(0)

# Return vector3 of current position
def get_curr_pos():
    message = Vector3Stamped()
    message.vector.x = init_dn
    message.vector.y = init_de
    message.vector.z = init_dd
    return message

# Update position data
def update_pos(data):
    global init_time_stamp
    global first_update

    # only unpack on first_update
    if first_update:
        init_time_stamp = data.header.stamp
        first_update = False
        return

    global init_an
    global init_ae
    global init_ad
    global init_vn
    global init_ve
    global init_vd
    global init_dn
    global init_de
    global init_dd

    # Unpack data
    an = data.vector.x
    ae = data.vector.y
    ad = data.vector.z
    delta_t = (data.header.stamp - init_time_stamp).to_sec()

    # Super basic filter to remove IMU output that is in high magnitude
    if abs(an) > 1.0 * 10 ** 3:
        an = init_an
    if abs(ae) > 1.0 * 10 ** 3:
        ae = init_ae
    if abs(ad) > 1.0 * 10 ** 3:
        ad = init_ad

    # Calculate distance using acceleration
    vn = init_vn + an * delta_t
    ve = init_ve + ae * delta_t
    vd = init_vd + ad * delta_t
    dn = init_dn + vn * delta_t + 0.5 * an * delta_t ** 2
    de = init_de + ve * delta_t + 0.5 * ae * delta_t ** 2
    dd = init_dd + vd * delta_t + 0.5 * ad * delta_t ** 2

    # Update initial variables for next calculation
    init_an = an
    init_ae = ae
    init_ad = ad
    init_vn = vn
    init_ve = ve
    init_vd = vd
    init_dn = dn
    init_de = de
    init_dd = dd
    init_time_stamp = data.header.stamp

def main():
    # Init node
    rospy.init_node('imu_kalman', anonymous=False)
    # Subscribe to earthAccel
    rospy.Subscriber("ngimu/earthAccel", Vector3Stamped, update_pos)
    # Create publisher
    pub = rospy.Publisher('imu_kalman/xyz', Vector3Stamped, queue_size=10)
    rate = rospy.Rate(10)  # Hz

    # start service
    # s = rospy.Service('get_position', GetPosition, get_position)
    # print "IMU service ready."
    #
    # rospy.spin()

    while not rospy.is_shutdown():
        message = get_curr_pos()
        pub.publish(message)
        rate.sleep()


if __name__ == "__main__":
    main()

"""
AUTHORS
Physics by Yash Chandak
ROS Interface by Matthew Fala
"""
'''
INFO
This is the IMU Service for collecting accelleration information and
providing location coordinates in meters

IMU Service USAGE
1) Wait for the service to load
      rospy.wait_for_service('get_position')

2) Create a Service Proxy
    pos_proxy = rospy.ServiceProxy('get_position', GetPosition)
    current_position = pos_proxy()

3) Get coordinates
   current_x = current_position.x
   current_y = current_position.y
   current_z = current_position.z

4) Make sure to handle exceptions
   except rospy.ServiceException, e:
       print "Service call failed: %s"%e

CONVENTION: D is the z axis and is used as a standard up, not down!!!

Notes:
There is a calibration error that is causing there to be a slight acceleration even when the IMU is sitting still.
We need to find a way to calibrate the IMU before testing.

The IMU outputs seemingly random values that exceed 1e10 in magnitude for acceleration. We need to use a simple
filter (use the previous value) to remove this. I have done this already.

In EarthAccel, the IMU starts to move after 5000 lines. In EarthAccelShortened, I removed those lines. I believe this
file is only when the IMU is not moving. Need to collect better data.

Need to implement the Kalman Filter.

Need to collect data of the IMU moving in a circle.

Need to figure out the units of the data given.
'''
